h2#combine-two Combine two observables

p.
  Just like in the <a href="#modify">"Modify an observable"</a> section,
  most of the methods in this section will return an observable of same type as the original
  observable (on which the method was called).



+descr-method('filter-by', 'filterBy', 'obs.filterBy(otherObs)').
  Works like <a href="#filter">filter</a>, but instead of calling a predicate
  on each value from #[b obs] observable, it checks the last value from #[b otherObs].

pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
    var bar = Kefir.sequentially(200, [false, true, false]).delay(40).toProperty(() => true);
    var result = foo.filterBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.filterBy] <value> 1
    > [sequentially.filterBy] <value> 2
    > [sequentially.filterBy] <value> 5
    > [sequentially.filterBy] <value> 6
    > [sequentially.filterBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4----5----6----7----8X
  bar:    t-----------f---------t---------fX

  result:  ----1----2--------------5----6----------X
div




+descr-method('obs-sampled-by', 'sampledBy', 'obs.sampledBy(otherObs, [combinator])').
  Returns a stream that emits the latest value from #[b obs] observable
  on each value from #[b otherObs]. Ends when #[b otherObs] ends.

p.
  You can also provide a
  #[b combinator] function which will be used to form the value emitted
  by the result stream. It is called with the latest values
  from #[b obs] and #[b otherObs] as arguments. The default #[b combinator]
  function is #[tt (a,&nbsp;b)&nbsp;=&gt;&nbsp;a].

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(200, [2, 3]).toProperty(() => 1);
    var b = Kefir.interval(100, 0).delay(40).take(5);
    var result = a.sampledBy(b);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.toProperty.sampledBy] <value> 1
    > [sequentially.toProperty.sampledBy] <value> 2
    > [sequentially.toProperty.sampledBy] <value> 2
    > [sequentially.toProperty.sampledBy] <value> 3
    > [sequentially.toProperty.sampledBy] <value> 3
    > [sequentially.toProperty.sampledBy] <end>

pre(title='events in time').
  a:      1---------2---------3X
  b:       ------0----0----0----0----0X

  result:  ------1----2----2----3----3X
div



+descr-method('skip-until-by', 'skipUntilBy', 'obs.skipUntilBy(otherObs)').
  Skips values form #[b obs] until the first value from #[b otherObs].

pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
    var bar = Kefir.later(250, 0);
    var result = foo.skipUntilBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.skipUntilBy] <value> 3
    > [sequentially.skipUntilBy] <value> 4
    > [sequentially.skipUntilBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4X
  bar:     -----------0X

  result:  --------------3----4X
div




+descr-method('take-until-by', 'takeUntilBy', 'obs.takeUntilBy(otherObs)').
  Takes values form #[b obs] until the first value form #[b otherObs] i.e.,
  ends on the first value from #[b otherObs].

pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
    var bar = Kefir.later(250, 0);
    var result = foo.takeUntilBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.takeUntilBy] <value> 1
    > [sequentially.takeUntilBy] <value> 2
    > [sequentially.takeUntilBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4X
  bar:     -----------0X

  result:  ----1----2-X
div




+descr-method('buffer-by', 'bufferBy', 'obs.bufferBy(otherObs, [options])').
  Buffers all values from #[b obs] observable, and flushes the buffer
  on each value from #[b otherObs]. Also flushes the buffer before end.

p.
  If #[tt options.flushOnEnd] is #[tt false], the buffer
  won't be flushed when the main observable ends.

p.
  The result observable will emit #[tt []] in cases, when the buffer supposed to be flushed,
  but it's empty.


pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]).delay(40);
    var bar = Kefir.sequentially(300, [1, 2])
    var result = foo.bufferBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.delay.bufferBy] <value> [1, 2]
    > [sequentially.delay.bufferBy] <value> [3, 4, 5]
    > [sequentially.delay.bufferBy] <value> [6, 7, 8]
    > [sequentially.delay.bufferBy] <end>

pre(title='events in time').
  foo:     ------1----2----3----4----5----6----7----8 X
  bar:     --------------1--------------2X

  result:  --------------•--------------•------------•X
                    [1, 2]      [3, 4, 5]    [6, 7, 8]
div





+descr-method('buffer-while-by', 'bufferWhileBy', 'obs.bufferWhileBy(otherObs, [options])').
  Similar to #[a(href="#buffer-while") bufferWhile], but instead of using a
  predicate function it uses another observable.
  On each value from #[b obs] observable:
  if the last value from #[b otherObs] was truthy, adds the new value to the buffer,
  otherwise flushes the buffer (with the new value included).

p.
  If #[tt options.flushOnEnd] is #[tt false], the buffer
  won't be flushed when the main observable ends.

p.
  If #[tt options.flushOnChange] is #[tt true], the buffer will be also flushed
  each time the controlling observable emits #[tt false].

p.
  The result observable will emit #[tt []] in cases, when the buffer supposed to be flushed,
  but it's empty.

p.
  The default options are #[tt {flushOnEnd: true, flushOnChange: false, emitEmpty: false}].


pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
    var bar = Kefir.sequentially(200, [false, true, false]).delay(40);
    var result = foo.bufferWhileBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.bufferWhileBy] <value> [1, 2, 3]
    > [sequentially.bufferWhileBy] <value> [4]
    > [sequentially.bufferWhileBy] <value> [5, 6, 7]
    > [sequentially.bufferWhileBy] <value> [8]
    > [sequentially.bufferWhileBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4----5----6----7----8X
  bar:     -----------f---------t---------fX

  result:  --------------•----•--------------•----•X
                 [1, 2, 3]  [4]      [5, 6, 7]  [8]
div

